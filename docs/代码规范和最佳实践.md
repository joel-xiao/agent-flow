# AgentFlow 代码规范和最佳实践

## 代码风格

### 命名规范

1. **模块和文件**：使用 snake_case
   ```rust
   // 正确
   mod image_processor;
   mod llm_client;
   
   // 错误
   mod ImageProcessor;
   mod LLMClient;
   ```

2. **类型和结构体**：使用 PascalCase
   ```rust
   struct ImageProcessor;
   struct LlmClient;
   enum AgentAction;
   ```

3. **函数和变量**：使用 snake_case
   ```rust
   fn process_image() {}
   let api_key = "...";
   ```

4. **常量**：使用 SCREAMING_SNAKE_CASE
   ```rust
   const MAX_RETRIES: u32 = 3;
   const DEFAULT_TIMEOUT: Duration = Duration::from_secs(30);
   ```

### 错误处理

**使用 Result 类型，不要 panic**

```rust
// ✅ 正确
pub fn load_config(path: &str) -> Result<Config> {
    let content = std::fs::read_to_string(path)
        .map_err(|e| AgentFlowError::Other(anyhow!("无法读取配置: {}", e)))?;
    // ...
}

// ❌ 错误
pub fn load_config(path: &str) -> Config {
    let content = std::fs::read_to_string(path).unwrap(); // 可能 panic
    // ...
}
```

**提供有意义的错误信息**

```rust
// ✅ 正确
Err(AgentFlowError::Other(anyhow!(
    "无法读取图像文件 {}: {}",
    path,
    e
)))

// ❌ 错误
Err(AgentFlowError::Other(anyhow!("Error")))
```

### 日志记录

**使用 tracing 而不是 println**

```rust
// ✅ 正确
use tracing::{info, warn, debug, error};

debug!(path = %image_path, "正在加载图像");
info!(agent = %agent_name, "Agent 已启动");
warn!(size_mb = file_size, "文件过大");
error!(error = ?err, "操作失败");

// ❌ 错误
println!("Loading image: {}", image_path);
eprintln!("Error: {:?}", err);
```

**日志级别使用指南**

- `error!`: 严重错误，需要立即处理
- `warn!`: 警告，可能存在问题但不影响运行
- `info!`: 重要信息，用户应该知道的事件
- `debug!`: 调试信息，开发时使用
- `trace!`: 最详细的跟踪信息

### 文档注释

**公共 API 必须有文档**

```rust
/// 处理图像文件并转换为 base64
/// 
/// # Arguments
/// 
/// * `path` - 图像文件路径
/// 
/// # Returns
/// 
/// base64 编码的图像数据
/// 
/// # Errors
/// 
/// 如果文件不存在或无法读取，返回错误
/// 
/// # Examples
/// 
/// ```no_run
/// use agentflow::flow::services::ImageProcessor;
/// 
/// let base64 = ImageProcessor::process_image_path("image.jpg")?;
/// ```
pub fn process_image_path(path: &str) -> Result<String> {
    // ...
}
```

## 性能最佳实践

### 1. 避免不必要的克隆

```rust
// ✅ 正确：使用引用
fn process_message(message: &str) {
    // ...
}

// ❌ 错误：不必要的克隆
fn process_message(message: String) {
    // ...
}

// 使用时
let msg = "hello";
process_message(msg); // 正确
// process_message(msg.to_string()); // 避免
```

### 2. 使用合适的数据结构

```rust
// 频繁查找：使用 HashMap
let mut cache: HashMap<String, Value> = HashMap::new();

// 顺序访问：使用 Vec
let items: Vec<Item> = vec![...];

// 去重：使用 HashSet
let unique_ids: HashSet<String> = HashSet::new();
```

### 3. 延迟初始化（Lazy Evaluation）

```rust
use once_cell::sync::Lazy;

static CACHE: Lazy<Arc<RwLock<HashMap<String, String>>>> = 
    Lazy::new(|| Arc::new(RwLock::new(HashMap::new())));
```

### 4. 使用缓存避免重复计算

```rust
// 检查缓存
if let Some(cached) = get_from_cache(key) {
    return Ok(cached);
}

// 计算
let result = expensive_operation()?;

// 存入缓存
store_in_cache(key, result.clone());
```

## 安全最佳实践

### 1. 不要硬编码敏感信息

```rust
// ❌ 错误
const API_KEY: &str = "sk-1234567890";

// ✅ 正确
let api_key = env::var("API_KEY")?;
```

### 2. 验证输入

```rust
pub fn set_temperature(temp: f64) -> Result<()> {
    if !(0.0..=2.0).contains(&temp) {
        return Err(AgentFlowError::Other(anyhow!(
            "温度必须在 0.0 到 2.0 之间"
        )));
    }
    // ...
}
```

### 3. 避免在日志中打印敏感信息

```rust
// ❌ 错误
debug!(api_key = %api_key, "Making request");

// ✅ 正确
debug!("Making request with API key");
// 或只显示部分
debug!(api_key = %mask_api_key(&api_key), "Making request");

fn mask_api_key(key: &str) -> String {
    if key.len() > 8 {
        format!("{}...{}", &key[..4], &key[key.len()-4..])
    } else {
        "***".to_string()
    }
}
```

## 并发最佳实践

### 1. 使用 Arc 而不是 Rc

```rust
// ✅ 正确：多线程环境
use std::sync::Arc;
let shared = Arc::new(data);

// ❌ 错误：Rc 不是线程安全的
use std::rc::Rc;
let shared = Rc::new(data);
```

### 2. 使用合适的锁

```rust
// 读多写少：使用 RwLock
use parking_lot::RwLock;
let cache = Arc::new(RwLock::new(HashMap::new()));

// 读写频繁：使用 Mutex
use parking_lot::Mutex;
let counter = Arc::new(Mutex::new(0));
```

### 3. 避免死锁

```rust
// ✅ 正确：及时释放锁
{
    let data = cache.read();
    process(&data);
} // 锁在这里自动释放

// ❌ 错误：锁持有时间过长
let data = cache.read();
expensive_operation();  // 锁一直持有
process(&data);
```

## 测试最佳实践

### 1. 单元测试

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_api_key_validation() {
        assert!(ConfigValidator::validate_api_key("").is_err());
        assert!(ConfigValidator::validate_api_key("sk-valid-key-123456").is_ok());
    }
    
    #[test]
    #[should_panic(expected = "invalid")]
    fn test_panic_case() {
        panic!("invalid");
    }
}
```

### 2. 异步测试

```rust
#[tokio::test]
async fn test_llm_client() {
    let client = create_test_client();
    let response = client.complete(request).await;
    assert!(response.is_ok());
}
```

### 3. 使用 Mock

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    struct MockLlmClient;
    
    #[async_trait]
    impl LlmClient for MockLlmClient {
        async fn complete(&self, _request: LlmRequest) -> Result<LlmResponse> {
            Ok(LlmResponse {
                content: "mock response".to_string(),
                metadata: None,
            })
        }
    }
}
```

## 配置管理最佳实践

### 1. 使用环境变量

```rust
// 支持环境变量引用
"api_key": "${QWEN_API_KEY}"

// 或省略，自动从默认环境变量读取
// "api_key" 字段省略
```

### 2. 提供默认值

```rust
let timeout = config.timeout.unwrap_or(Duration::from_secs(30));
let max_retries = config.max_retries.unwrap_or(3);
```

### 3. 验证配置

```rust
impl GraphConfig {
    pub fn validate(&self) -> Result<()> {
        // 验证节点 ID 唯一性
        let mut node_ids = HashSet::new();
        for node in &self.nodes {
            if !node_ids.insert(&node.id) {
                return Err(AgentFlowError::Other(anyhow!(
                    "重复的节点 ID: {}",
                    node.id
                )));
            }
        }
        Ok(())
    }
}
```

## 代码组织

### 1. 模块结构

```
src/
├── agent/          # Agent 相关
│   ├── agent.rs
│   ├── factory.rs
│   └── registry.rs
├── flow/           # 工作流相关
│   ├── builder.rs
│   ├── nodes.rs
│   └── types.rs
├── config/         # 配置相关
│   ├── graph.rs
│   ├── env.rs
│   └── validation.rs
└── utils/          # 工具函数
    ├── logging.rs
    └── validation.rs
```

### 2. 依赖方向

- 高层模块依赖低层模块
- 避免循环依赖
- 使用 trait 实现依赖倒置

```
runtime (高层)
   ↓
flow
   ↓
agent → llm → config (低层)
```

## 常见陷阱

### 1. 忘记处理 Option/Result

```rust
// ❌ 错误
let value = map.get("key").unwrap();

// ✅ 正确
let value = map.get("key")
    .ok_or_else(|| AgentFlowError::Other(anyhow!("Key not found")))?;
```

### 2. 字符串处理

```rust
// ❌ 低效
let s = format!("{}", value); // 如果 value 已经是 String

// ✅ 正确
let s = value.to_string();
// 或者直接使用引用
fn process(s: &str) { ... }
```

### 3. 忽略返回值

```rust
// ❌ 错误
write_to_file(data); // Result 被忽略

// ✅ 正确
write_to_file(data)?;
// 或明确忽略
let _ = write_to_file(data);
```

## 代码审查清单

开发时检查以下项：

- [ ] 所有公共 API 都有文档注释
- [ ] 错误信息清晰且有帮助
- [ ] 使用 tracing 而不是 println
- [ ] 没有硬编码的敏感信息
- [ ] 输入都经过验证
- [ ] 使用 Result 处理错误，避免 unwrap
- [ ] 锁的持有时间最小化
- [ ] 添加了必要的测试
- [ ] 代码格式化（`cargo fmt`）
- [ ] 通过 clippy 检查（`cargo clippy`）

## 工具使用

```bash
# 格式化代码
cargo fmt

# Lint 检查
cargo clippy --all-targets --all-features

# 运行测试
cargo test --all-features

# 检查文档
cargo doc --no-deps --open

# 依赖审计
cargo audit
```

## 总结

遵循这些最佳实践可以：
- 提高代码质量
- 减少 bug
- 提升性能
- 改善可维护性
- 增强安全性

记住：**写代码容易，写好代码难。花时间遵循最佳实践是值得的！**

