# AgentFlow 工具系统架构

## 核心设计理念

1. **内置工具自动注册**：框架层面自动加载内置工具，无需应用层手动注册
2. **配置驱动**：通过 JSON 配置定义工具节点和执行流程
3. **易于扩展**：支持用户自定义工具，与内置工具使用方式一致
4. **Pipeline 模式**：工具通过 pipeline 组合，支持多种执行策略

## 架构层次

```
┌─────────────────────────────────────────────────────────────┐
│                     应用层 (Application)                     │
│  ┌───────────────┐  ┌───────────────┐  ┌──────────────┐    │
│  │ JSON 配置      │  │ Pipeline 定义  │  │ 自定义工具    │    │
│  │ tool_node     │  │ Sequential    │  │ MyTool       │    │
│  └───────────────┘  └───────────────┘  └──────────────┘    │
└──────────────────────────┬──────────────────────────────────┘
                           │
┌──────────────────────────▼──────────────────────────────────┐
│                    框架层 (Framework)                        │
│  ┌────────────────────────────────────────────────────┐    │
│  │         FlowExecutor + ToolOrchestrator             │    │
│  │  - 工作流执行                                        │    │
│  │  - Tool pipeline 管理                               │    │
│  │  - 执行策略控制                                      │    │
│  └────────────────────────────────────────────────────┘    │
│  ┌────────────────────────────────────────────────────┐    │
│  │              ToolRegistry                           │    │
│  │  - 工具注册表                                        │    │
│  │  - 工具查找                                          │    │
│  │  - Manifest 管理                                    │    │
│  └────────────────────────────────────────────────────┘    │
└─────────────────────────┬───────────────────────────────────┘
                          │
┌─────────────────────────▼───────────────────────────────────┐
│                   内置工具层 (Built-in Tools)                │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │ Downloader   │  │ ImageGen     │  │ Echo         │     │
│  │ Tool         │  │ Tool         │  │ Tool         │     │
│  └──────────────┘  └──────────────┘  └──────────────┘     │
│         ✅ 自动注册              ✅ 自动注册                 │
└─────────────────────────────────────────────────────────────┘
```

## 核心组件

### 1. Tool Trait

所有工具必须实现的接口：

```rust
#[async_trait]
pub trait Tool: Send + Sync {
    fn name(&self) -> &'static str;
    
    async fn call(
        &self,
        invocation: ToolInvocation,
        ctx: &FlowContext
    ) -> Result<AgentMessage>;
}
```

### 2. ToolRegistry

工具注册表，管理所有工具实例：

```rust
pub struct ToolRegistry {
    tools: HashMap<String, ToolEntry>,
}

impl ToolRegistry {
    pub fn register(&mut self, tool: Arc<dyn Tool>);
    pub fn get(&self, name: &str) -> Option<Arc<dyn Tool>>;
}
```

**自动注册内置工具的位置**：
```rust
// src/flow/loader/workflow_loader.rs
let mut tools = ToolRegistry::new();

// 注册内置工具（自动）
tools.register(Arc::new(DownloaderTool::new()));
tools.register(Arc::new(ImageGeneratorTool::new()));

// 注册配置中的自定义工具
for profile in &config.tools {
    tools.register(Arc::new(ConfigDrivenTool { ... }));
}
```

### 3. ToolOrchestrator

工具编排器，管理 pipeline 和执行策略：

```rust
pub struct ToolOrchestrator {
    registry: ToolRegistry,
    pipelines: HashMap<String, ToolPipeline>,
}

impl ToolOrchestrator {
    pub fn new(registry: ToolRegistry) -> Self;
    pub fn register_pipeline(&mut self, pipeline: ToolPipeline) -> Result<()>;
    pub async fn execute_pipeline(&self, name: &str, ctx: &FlowContext) -> Result<AgentMessage>;
}
```

### 4. ToolPipeline

工具管道，定义工具执行流程：

```rust
pub struct ToolPipeline {
    pub name: String,
    pub strategy: ToolStrategy,
    pub output_manifest: Option<ToolManifest>,
}

pub enum ToolStrategy {
    Sequential(Vec<ToolStep>),  // 顺序执行
    Parallel(Vec<ToolStep>),    // 并行执行
    Fallback(Vec<ToolStep>),    // 故障转移
}

pub struct ToolStep {
    pub tool: String,           // 工具名称
    pub input: Value,           // 输入参数
    pub timeout: Option<Duration>,
    pub retries: u32,
}
```

### 5. FlowExecutor

流程执行器，协调整个工作流：

```rust
pub struct FlowExecutor {
    flow: Arc<Flow>,
    agents: Arc<AgentRegistry>,
    tools: Arc<ToolRegistry>,
    tool_orchestrator: Option<Arc<ToolOrchestrator>>,
}

impl FlowExecutor {
    pub fn new(flow: Flow, agents: AgentRegistry, tools: ToolRegistry) -> Self;
    pub fn with_tool_orchestrator(mut self, orchestrator: Arc<ToolOrchestrator>) -> Self;
    pub async fn start(&self, ctx: Arc<FlowContext>, initial: AgentMessage) -> Result<FlowExecution>;
}
```

## 执行流程

### 1. 初始化阶段

```
1. 加载 GraphConfig from JSON
   └─> GraphConfig::from_json()
   
2. 加载 Workflow
   └─> graph_config.load_workflow()
       ├─> 创建 Flow
       ├─> 注册 Agents
       └─> 创建 ToolRegistry
           ├─> ✅ 自动注册内置工具 (DownloaderTool, ImageGeneratorTool)
           └─> 注册配置中的自定义工具

3. 创建 ToolOrchestrator
   └─> ToolOrchestrator::new(bundle.tools)
       └─> 注册 Pipelines
           ├─> register_pipeline("download_file", Sequential([downloader]))
           ├─> register_pipeline("image_gen", Sequential([image_gen]))
           └─> ... 其他 pipelines

4. 创建 FlowExecutor
   └─> FlowExecutor::new(flow, agents, tools)
       .with_tool_orchestrator(orchestrator)
```

### 2. 运行阶段

```
FlowExecutor::start(ctx, initial_message)
  │
  ├─> 处理节点
  │   ├─> Agent Node → 调用 LLM
  │   ├─> Decision Node → 条件判断
  │   ├─> Join Node → 汇聚结果
  │   └─> Tool Node → 执行工具 ✅
  │       │
  │       └─> ToolOrchestrator::execute_pipeline(pipeline_name, ctx)
  │           │
  │           ├─> 查找 Pipeline
  │           │
  │           ├─> 执行策略
  │           │   ├─> Sequential: 依次执行工具
  │           │   ├─> Parallel: 并发执行工具
  │           │   └─> Fallback: 尝试执行直到成功
  │           │
  │           └─> 对每个 ToolStep:
  │               ├─> ToolRegistry::get(tool_name)
  │               ├─> Tool::call(invocation, ctx)
  │               └─> 返回 AgentMessage
  │
  └─> 返回 FlowExecution
```

### 3. 工具执行详情

以 DownloaderTool 为例：

```
ToolOrchestrator::execute_step(ToolStep)
  │
  └─> ToolRegistry::get("downloader")
      │
      └─> DownloaderTool::call(invocation, ctx)
          │
          ├─> 1. 提取 URL
          │   ├─> 优先使用 invocation.input["url"]
          │   └─> 否则从 ctx.history() 中自动提取
          │       ├─> 查找 "image_url"
          │       ├─> 查找 "url"
          │       ├─> 查找 "file_url"
          │       └─> 查找 "download_url"
          │
          ├─> 2. 下载文件
          │   ├─> reqwest::get(url)
          │   └─> 保存到本地
          │
          └─> 3. 返回结果
              └─> AgentMessage {
                      content: json!({
                          "success": true,
                          "filepath": "...",
                          "size_bytes": ...
                      })
                  }
```

## 内置工具实现

### DownloaderTool

**文件位置**：`src/tools/downloader.rs`

**核心功能**：
1. 自动从上下文提取 URL
2. 支持多种文件类型
3. 智能推断文件扩展名
4. 返回详细的下载结果

**关键代码**：
```rust
impl Tool for DownloaderTool {
    fn name(&self) -> &'static str {
        "downloader"  // 工具名称
    }
    
    async fn call(&self, invocation: ToolInvocation, ctx: &FlowContext) -> Result<AgentMessage> {
        // 1. 获取 URL（优先参数，否则自动提取）
        let url = invocation.input["url"]
            .as_str()
            .map(|s| s.to_string())
            .or_else(|| Self::extract_url_from_context(ctx))
            .ok_or(...)?;
        
        // 2. 下载并保存
        let response = self.client.get(&url).send().await?;
        fs::write(&filepath, bytes)?;
        
        // 3. 返回结果
        Ok(AgentMessage { ... })
    }
}
```

### 自动注册机制

**文件位置**：`src/flow/loader/workflow_loader.rs`

```rust
pub fn load_workflow_from_value(value: &Value) -> Result<WorkflowBundle> {
    // ... 加载 agents ...
    
    let mut tools = ToolRegistry::new();
    
    // ✅ 内置工具自动注册
    tools.register(Arc::new(crate::tools::DownloaderTool::new()));
    tools.register(Arc::new(crate::tools::ImageGeneratorTool::new()));
    
    // 注册配置中的自定义工具
    for profile in &config.tools {
        tools.register(Arc::new(ConfigDrivenTool { ... }));
    }
    
    Ok(WorkflowBundle { flow, agents, tools })
}
```

## JSON 配置示例

完整的工作流配置，包含工具节点：

```json
{
  "name": "marketing_content_generator",
  "nodes": [
    {
      "id": "agent_image_generator",
      "type": "agent",
      "config": {
        "name": "image_generator",
        "model": "wan2.5-t2i-preview",
        "endpoint": "https://dashscope.aliyuncs.com/api/v1/services/aigc/text2image/image-synthesis"
      }
    },
    {
      "id": "tool_downloader",
      "type": "tool_node",
      "config": {
        "pipeline": "download_file"
      }
    },
    {
      "id": "agent_result_summarizer",
      "type": "agent",
      "config": {
        "name": "result_summarizer",
        "model": "qwen-max"
      }
    }
  ],
  "edges": [
    {
      "from": "agent_image_generator",
      "to": "tool_downloader",
      "type": "always"
    },
    {
      "from": "tool_downloader",
      "to": "agent_result_summarizer",
      "type": "always"
    }
  ]
}
```

## 扩展新工具的步骤

### 1. 创建工具文件

`src/tools/my_custom_tool.rs`:

```rust
use async_trait::async_trait;
use crate::tools::tool::{Tool, ToolInvocation};
use crate::agent::{AgentMessage, MessageRole};
use crate::error::Result;
use crate::state::FlowContext;

pub struct MyCustomTool {
    // 工具配置
}

impl MyCustomTool {
    pub fn new() -> Self {
        Self { }
    }
}

#[async_trait]
impl Tool for MyCustomTool {
    fn name(&self) -> &'static str {
        "my_custom_tool"
    }
    
    async fn call(&self, invocation: ToolInvocation, ctx: &FlowContext) -> Result<AgentMessage> {
        // 实现工具逻辑
        Ok(AgentMessage {
            id: crate::agent::message::uuid(),
            role: MessageRole::Tool,
            from: self.name().to_string(),
            to: None,
            content: "result".to_string(),
            metadata: None,
        })
    }
}
```

### 2. 导出工具

`src/tools/mod.rs`:

```rust
pub mod my_custom_tool;
pub use my_custom_tool::MyCustomTool;
```

### 3. （可选）自动注册

如果希望作为内置工具，在 `src/flow/loader/workflow_loader.rs` 添加：

```rust
tools.register(Arc::new(MyCustomTool::new()));
```

### 4. 使用工具

```rust
// 注册 pipeline
orchestrator.register_pipeline(ToolPipeline::new(
    "my_custom_pipeline",
    ToolStrategy::Sequential(vec![
        ToolStep::new("my_custom_tool", serde_json::json!({
            "param": "value"
        }))
    ])
))?;
```

```json
{
  "id": "tool_custom",
  "type": "tool_node",
  "config": {
    "pipeline": "my_custom_pipeline"
  }
}
```

## 总结

AgentFlow 的工具系统设计实现了：

✅ **零配置内置工具**：DownloaderTool 等内置工具自动注册  
✅ **灵活的扩展性**：自定义工具与内置工具使用方式一致  
✅ **Pipeline 组合**：支持顺序、并行、故障转移等执行策略  
✅ **上下文感知**：工具可自动从执行上下文提取所需信息  
✅ **JSON 配置驱动**：通过 tool_node 在工作流中声明式使用工具  
✅ **类型安全**：基于 Rust trait 系统，编译时类型检查  

这种设计使得 AgentFlow 既易于使用（内置工具开箱即用），又具有强大的扩展能力（自定义工具无缝集成）。

